<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络模型 | 她说</title>
    <meta name="description" content="我的个人网站">
    <link rel="icon" href="/img/meat.ico">
    
    <link rel="preload" href="/assets/css/0.styles.2e32879c.css" as="style"><link rel="preload" href="/assets/js/app.d72ea573.js" as="script"><link rel="preload" href="/assets/js/3.d2293747.js" as="script"><link rel="prefetch" href="/assets/js/2.3b9d6b7b.js"><link rel="prefetch" href="/assets/js/4.9953e9d4.js"><link rel="prefetch" href="/assets/js/5.452037c8.js"><link rel="prefetch" href="/assets/js/6.081a2e41.js"><link rel="prefetch" href="/assets/js/7.e7631b49.js"><link rel="prefetch" href="/assets/js/8.dde3f876.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2e32879c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="她说" class="logo"> <span class="site-name can-hide">她说</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">学习笔记</a></div><div class="nav-item"><a href="https://github.com/tashuobutianhei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Guide
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">学习笔记</a></div><div class="nav-item"><a href="https://github.com/tashuobutianhei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Guide
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>vue学习</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Front/docVue/vue.html" class="sidebar-link">vue源码分析</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>前端部署</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Front/docfront/bushu.html" class="sidebar-link">静态文件和非静态文件</a></li><li><a href="/Front/docfront/fenli.html" class="sidebar-link">记录一下前后端分离的知识</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>计算机网络知识</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Front/docNet/net.html" class="active sidebar-link">网络模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#网络模型" class="sidebar-link">网络模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#_1-分层方式" class="sidebar-link">1.分层方式</a></li></ul></li><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#各层的作用" class="sidebar-link">各层的作用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#_1-物理层" class="sidebar-link">1. 物理层</a></li><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#_2-数据链路层" class="sidebar-link">2. 数据链路层</a></li><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#_3-网络层" class="sidebar-link">3. 网络层</a></li><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#_4-传输层" class="sidebar-link">4. 传输层</a></li><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#_5-应用层（会话层、表示层、应用层）" class="sidebar-link">5. 应用层（会话层、表示层、应用层）</a></li><li class="sidebar-sub-header"><a href="/Front/docNet/net.html#访问网页发生了什么？" class="sidebar-link">访问网页发生了什么？</a></li></ul></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="网络模型"><a href="#网络模型" aria-hidden="true" class="header-anchor">#</a> 网络模型</h2> <h3 id="_1-分层方式"><a href="#_1-分层方式" aria-hidden="true" class="header-anchor">#</a> 1.分层方式</h3> <p>网络模型分为：<strong>OSI七层模型</strong>、<strong>五层模型</strong>、<strong>TCP/IP四层模型</strong></p> <p><img src="en-resource://database/1398:1" alt="99a747d63b0808f8f955b35bbfaa1e3f.png"></p> <p><img src="en-resource://database/1399:1" alt="ef9001129644a309ce3e7b0c4efcdbac.png"></p> <h4 id="_1-1-osi七层模型"><a href="#_1-1-osi七层模型" aria-hidden="true" class="header-anchor">#</a> 1.1 OSI七层模型</h4> <p><strong>OSI七层协议模型主要是：</strong></p> <blockquote><p>应用层（Application）                 &lt;———（第七层）
表示层（Presentation）
会话层（Session）
传输层（Transport）
网络层（Network）
数据链路层（Data Link）
物理层（Physical）                     &lt;———（第一层）</p></blockquote> <p><strong>OSI分层的优点：</strong>
（1）人们可以很容易的讨论和学习协议的规范细节。 
（2）层间的标准接口方便了工程模块化。 
（3）创建了一个更好的互连环境。 
（4）降低了复杂度，使程序更容易修改，产品开发的速度更快。 
（5）每层利用紧邻的下层服务，更容易记住个层的功能。</p> <h4 id="_1-2-tcp-ip-四层模型"><a href="#_1-2-tcp-ip-四层模型" aria-hidden="true" class="header-anchor">#</a> 1.2 TCP/IP 四层模型</h4> <p>TCP/IP是一个<strong>四层</strong>的<strong>体系结构</strong>
主要包括：应用层、运输层、网际层和网络接口层。
从实质上讲，只有上边三层，网络接口层没有什么具体的内容。
<img src="en-resource://database/1396:1" alt="5d3ba9a9d63206ee12aafcd7d00dbfdb.png"></p> <h4 id="_1-3-五层体系结构"><a href="#_1-3-五层体系结构" aria-hidden="true" class="header-anchor">#</a> 1.3 五层体系结构</h4> <p>五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。</p> <p>五层协议只是OSI和TCP/IP的综合，实际应用还是TCP/IP的四层结构。为了方便可以把下两层称为网络接口层。</p> <h2 id="各层的作用"><a href="#各层的作用" aria-hidden="true" class="header-anchor">#</a> 各层的作用</h2> <h3 id="_1-物理层"><a href="#_1-物理层" aria-hidden="true" class="header-anchor">#</a> 1. 物理层</h3> <p>电脑要组网，首先就是要把电脑连起来，可以用 <strong>光缆、电缆、双绞线、无线电波</strong> 等方式。
<img src="en-resource://database/1406:1" alt="95e3e0e33bd5e99bc449dffa573d4406.png"></p> <p>这一层主要定义<strong>物理设备</strong>标准，如<strong>网线的接口类型、光纤的接口类型、各种传输介质的传输速率</strong>等。</p> <p>它的主要作用是 <strong>传输比特流</strong> （就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的 <strong>数模转换</strong> 与 <strong>模数转换</strong>）。</p> <p>这一层的数据叫做 <strong>比特。</strong></p> <h3 id="_2-数据链路层"><a href="#_2-数据链路层" aria-hidden="true" class="header-anchor">#</a> 2. 数据链路层</h3> <p>单纯的0和1没有任何意义，所以我们要规定解读方式：多少个信号算一组？每个信号位有什么意义？</p> <p>这就是“数据链路层“的功能，定义了如何让 <strong>格式化数据</strong> 以进行传输，以及如何让控制 <strong>对物理介质的访问</strong>。
这一层通常还提供 <strong>错误检测和纠正</strong> ，以确保数据的可靠传输。</p> <h4 id="_2-1-以太网协议-（数据的格式是怎么样规定的？）"><a href="#_2-1-以太网协议-（数据的格式是怎么样规定的？）" aria-hidden="true" class="header-anchor">#</a> 2.1 以太网协议 （数据的格式是怎么样规定的？）</h4> <p>&quot;以太网&quot;（Ethernet）的协议，规定了<strong>电信号分组方式</strong>。
<strong>以太网规定</strong>：一组电信号构成一个数据包，叫做&quot;<strong>帧</strong>&quot;（Frame）。每一帧分成两个部分：<strong>标头（Head）</strong> 和 <strong>数据（Data）</strong> <img src="en-resource://database/1407:1" alt="a2378014df3f7f9f9ac3d7dc00593bce.png"></p> <p><strong>标头</strong>：包含数据包的一些说明项，比如<strong>发送者（源物理地址）</strong>、<strong>接受者（目的物理地址）</strong>、<strong>数据类型</strong>、<strong>CRC校验码</strong>等等。
<strong>数据</strong>：则是数据包的具体内容。</p> <p>具体的帧结构如下图所示：
<img src="en-resource://database/1401:1" alt="22c25ed4ef2d844f51ca73a5993ba574.png"></p> <p>&quot;标头&quot;的长度，固定为18（6+6+2+4）字节。
&quot;数据&quot;的长度，最短为46字节，最长为1500字节。
因此，整个&quot;帧&quot;最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p> <h4 id="_2-2-mac-地址（用什么标识？）"><a href="#_2-2-mac-地址（用什么标识？）" aria-hidden="true" class="header-anchor">#</a> 2.2 MAC 地址（用什么标识？）</h4> <p>以太网协议中的标头包含一些说明项，如：发送者、接收者、数据类型等。
那么他是怎么标识的呢？</p> <p>以太网规定，连入网络的所有设备，都必须具有 &quot;<strong>网卡</strong>&quot; 接口。
<strong>数据包</strong>必须是<strong>从一块网卡</strong>，<strong>传送到另一块网卡</strong>。
<strong>网卡的地址</strong>，就是<strong>数据包</strong>的<strong>发送地址</strong>和<strong>接收地址</strong>，这叫做<strong>MAC地址</strong>。
<strong>每块网卡</strong>出厂的时候，都有一个全世界<strong>独一无二的MAC地址</strong>，长度是48个二进制位，通常用12个十六进制数表示。
<img src="en-resource://database/1405:1" alt="641279c07aaa53ed8e3ac91423194ff0.png"></p> <p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p> <h4 id="_2-3-arp协议（怎么找到对方的标识？）"><a href="#_2-3-arp协议（怎么找到对方的标识？）" aria-hidden="true" class="header-anchor">#</a> 2.3 ARP协议（怎么找到对方的标识？）</h4> <p>一块网卡怎么会知道另一块网卡的MAC地址？
<strong>ARP协议（地址解析协议）</strong> 可以解决这个问题。</p> <p>ARP协议将 <strong>IP 地址转化为 MAC 物理地址</strong>。
在A不知道B的MAC地址的情况下，A就发送一个 <strong>ARP request</strong>，这个 request 是一个没有指定目的地的广播， <strong>广播一个ARP请求包</strong> ，
请求包中填有B的IP(192.168.1.2)，以太网中的所有计算机都会接收这个请求，
而正常的情况下只有B会给出ARP应答包，包中就填充上了B的MAC地址，并回复给A一个 <strong>ARP reply</strong>，
ARP reply是有明确目标地址的，是<strong>单播</strong>。     
A得到ARP应答后，将B的MAC地址放入本机缓存，便于下次使用。     
本机MAC缓存是有生存期的，生存期结束后，将再次重复上面的过程。</p> <h4 id="_2-4-广播-（怎么把数据发出去？）"><a href="#_2-4-广播-（怎么把数据发出去？）" aria-hidden="true" class="header-anchor">#</a> 2.4 广播 （怎么把数据发出去？）</h4> <p>有了MAC地址后，系统怎样才能把数据包准确送到接收方？
以太网采用了一种很&quot;原始&quot;的方式，它不是把数据包准确送到接收方，而是<strong>向本网络内所有计算机发送</strong>，让每台计算机自己<strong>判断，是否为接收方</strong>。</p> <p>上面获取 MAC 地址的时候也提到了广播。什么是广播？
广播：网络广播是指<strong>一个节点同时向相同域中的其它所有节点传输数据包</strong>的过程。
<img src="en-resource://database/1404:1" alt="6241fd8e3f60697d656c18d754e9187c.png"></p> <p>1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的&quot;标头&quot;，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做&quot;广播&quot;（broadcasting）。</p> <p>有了数据包的定义、网卡的MAC地址、广播的发送方式，&quot;链接层&quot;就可以在多台计算机之间传送数据了。</p> <h3 id="_3-网络层"><a href="#_3-网络层" aria-hidden="true" class="header-anchor">#</a> 3. 网络层</h3> <h4 id="_3-0-什么是网络层-（我要和别的地区的人网上冲浪！）"><a href="#_3-0-什么是网络层-（我要和别的地区的人网上冲浪！）" aria-hidden="true" class="header-anchor">#</a> 3.0 什么是网络层 （我要和别的地区的人网上冲浪！）</h4> <p>在位于 <strong>不同地理位置</strong> 的网络中的 <strong>两个主机系统</strong> 之间提供 <strong>连接</strong> 和 <strong>路径选择</strong> 。
Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p> <hr> <p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p> <p>但是以太网采用广播方式发送数据包，所有成员<strong>人手一&quot;包&quot;，效率很低</strong>。
而且 <strong>并不是所有的网卡都是在同一个子网络</strong> 上的。以太网协议的广播方式，<strong>只能局限在发送者所在的子网络</strong>。
也就是说，如果两台计算机<strong>不在同一个子网络，广播是传不过去的</strong>。
这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p> <p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用 &quot;<strong>路由</strong>&quot; 方式发送。（ <strong>&quot;路由&quot;的意思，就是指如何向不同的子网络分发数据包</strong> ）<strong>MAC地址</strong> 本身无法做到这一点。<strong>它只与厂商有关，与所处网络无关</strong>。</p> <p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p> <p>&quot;网络层”出现以后，每台计算机有了两种地址，一种是 <strong>MAC地址</strong> ，另一种是 <strong>网络地址</strong> 。
两种地址之间<strong>没有任何联系</strong>，
<strong>MAC地址是绑定在网卡上的，网络地址则是管理员分配的</strong>，它们只是随机组合在一起（因此网址可以变化）。</p> <p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是<strong>先处理网络地址，然后再处理MAC地址</strong>。</p> <h4 id="_3-1-ip协议（我的另一个标识，网络地址）"><a href="#_3-1-ip协议（我的另一个标识，网络地址）" aria-hidden="true" class="header-anchor">#</a> 3.1 IP协议（我的另一个标识，网络地址）</h4> <p>规定 <strong>网络地址的协议</strong> ，叫做 <strong>IP协议</strong>。<strong>它所定义的地址</strong>，就被称为 <strong>IP地址</strong> 。</p> <p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。
<img src="en-resource://database/1400:1" alt="02fad2d1373264ae030dca74611bc9d6.png"></p> <p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p> <p>互联网上的每一台计算机，都会分配到一个IP地址。
IP地址分成 <strong>两个部分</strong>：前一部分代表 <strong>网络</strong>，后一部分代表 <strong>主机</strong>。</p> <p>比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。</p> <p><strong>处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的</strong>，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p> <h4 id="_3-2-子网掩码-（我们是一个子网吗？）"><a href="#_3-2-子网掩码-（我们是一个子网吗？）" aria-hidden="true" class="header-anchor">#</a> 3.2 子网掩码 （我们是一个子网吗？）</h4> <p>所谓”子网掩码”，就是表示子网络特征的一个参数，用于判断两个 IP 是否处于同一个子网。</p> <p>它在形式上等同于IP地址，也是一个32位二进制数字，它的 <strong>网络部分全部为1，主机部分全部为0</strong>。</p> <p>子网编码中网络部分占多少位是不一定的。</p> <p>比如，IP地址172.16.254.1，如果<strong>已知网络部分是前24位</strong>，<strong>主机部分是后8位</strong>，<strong>那么子网络掩码就是11111111.11111111.11111111.00000000</strong>，写成十进制就是255.255.255.0。</p> <p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。</p> <hr> <p><strong>方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同</strong>，如果是的话，就表明它们在同一个子网络中，否则就不是。</p> <h4 id="_3-3-ip数据包（把新的数据加进去）"><a href="#_3-3-ip数据包（把新的数据加进去）" aria-hidden="true" class="header-anchor">#</a> 3.3 IP数据包（把新的数据加进去）</h4> <p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p> <p>以太网数据包只包含MAC地址，并没有IP地址的栏位。</p> <p>我们可以把<strong>IP数据包直接放进以太网数据包的&quot;数据&quot;部分</strong>，因此完全<strong>不用修改以太网的规格</strong>。
<strong>这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</strong></p> <p>IP 数据包也分为“标头”和“数据”两个部分：
<img src="en-resource://database/1402:1" alt="4ba64763836369a1346eec05f192ee69.png"></p> <p>&quot;标头&quot;部分主要包括版本、长度、IP地址等信息，&quot;数据&quot;部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。
<img src="en-resource://database/1403:1" alt="56ef8038c5ca9616e07c4d48bf825343.png"></p> <p>IP数据包的&quot;标头&quot;部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的&quot;数据&quot;部分，最长为65,515字节。前面说过，以太网数据包的&quot;数据&quot;部分，最长只有1500字节。因此，<strong>如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了</strong>。</p> <h3 id="_4-传输层"><a href="#_4-传输层" aria-hidden="true" class="header-anchor">#</a> 4. 传输层</h3> <p>定义了一些 <strong>传输数据的协议和端口号</strong>（WWW端口80等），
如： 
<strong>TCP</strong>（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据） 
<strong>UDP</strong>（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</p> <h4 id="_4-0-什么是传输层"><a href="#_4-0-什么是传输层" aria-hidden="true" class="header-anchor">#</a> 4.0 什么是传输层</h4> <p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。
但是当我们运行许多程序时，怎么区分发送来的数据是供哪一个进程使用的？
这时候就需要一个新的参数，来表示这个数据包到底供那个进程使用，于是 <strong>“端口”(port)</strong> 出现了。</p> <h4 id="_4-1-端口（哪个程序的数据？）"><a href="#_4-1-端口（哪个程序的数据？）" aria-hidden="true" class="header-anchor">#</a> 4.1 端口（哪个程序的数据？）</h4> <p>&quot;端口&quot;（port），它其实是每一个 <strong>使用网卡的程序的编号</strong> 。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p> <p>&quot;端口&quot;是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p> <p><strong>&quot;传输层&quot;的功能，就是建立&quot;端口到端口&quot;的通信</strong>。相比之下， <strong>&quot;网络层&quot;的功能是建立&quot;主机到主机&quot;的通信</strong>。
只要确定主机和端口，我们就能实现程序之间的交流。
因此，Unix系统就把主机+端口，叫做&quot;套接字&quot;（socket）。有了它，就可以进行网络应用程序开发了。</p> <h4 id="_4-2-udp协议"><a href="#_4-2-udp协议" aria-hidden="true" class="header-anchor">#</a> 4.2 UDP协议</h4> <p>好了我们现在要在数据包中加入端口信息了。
加新信息就需要新的协议了，最简单的实现是UDP协议，他的格式几乎就是在数据前面加上端口号。</p> <p>UDP数据包，也是由“标头”和“数据”两部分组成。
<img src="en-resource://database/1411:1" alt="fe5640249e4864c8a674b7bf67ca06a0.png"></p> <p>&quot;<strong>标头</strong>&quot;部分主要定义了发出端口和接收端口，
&quot;<strong>数据</strong>&quot;部分就是具体的内容。</p> <p>然后，把整个UDP数据包放入IP数据包的&quot;数据&quot;部分，
IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样</p> <p><img src="en-resource://database/1409:1" alt="31d4c72023151547a5faebec03497dbf.png"></p> <p>UDP数据包非常简单，&quot;标头&quot;部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p> <h4 id="_4-3-tcp协议"><a href="#_4-3-tcp协议" aria-hidden="true" class="header-anchor">#</a> 4.3 TCP协议</h4> <p><strong>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</strong></p> <p>为了提高网路的可靠性，TCP协议诞生了，可以近似认为，他就是 <strong>有确认机制的UDP协议</strong>，
每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p> <p><strong>TCP协议能够确保数据不会遗失。</strong> <strong>它的缺点是：
过程复杂：（TCP三次握手、四次挥手等）
实现困难：（数据重传机制、流量控制机制等）
消耗较多的资源。</strong></p> <p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的&quot;数据&quot;部分。</p> <h3 id="_5-应用层（会话层、表示层、应用层）"><a href="#_5-应用层（会话层、表示层、应用层）" aria-hidden="true" class="header-anchor">#</a> 5. 应用层（会话层、表示层、应用层）</h3> <p>会话层,表示层,应用层构成开放系统的高3层，面对应用进程提供<strong>分布处理、对话管理、信息表示、恢复最后的差错</strong>等。</p> <p>TCP协议通过端口号，可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。
那么，必须有 <strong>不同协议规定电子邮件、网页、FTP数据的格式</strong> ，这些 <strong>应用程序协议就构成了&quot;应用层&quot;</strong>。</p> <p>应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。</p> <h4 id="_5-1-会话层"><a href="#_5-1-会话层" aria-hidden="true" class="header-anchor">#</a> 5.1 会话层</h4> <p>通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。
主要在你的系统之间 <strong>发起会话或者接受会话请求</strong>（设备之间需要互相认识可以是 <strong>IP</strong> 也可以是 <strong>MAC</strong> 或者是 <strong>主机名</strong> ）</p> <p>会话层（Session）提供的服务可<strong>使应用建立和维持会话</strong>，并能<strong>使会话获得同步</strong>。
会话层 <strong>使用校验点使通信会话在通信失效时从校验点继续恢复通信</strong>。这种能力对于传送大的文件极为重要。</p> <h4 id="_5-2-表示层"><a href="#_5-2-表示层" aria-hidden="true" class="header-anchor">#</a> 5.2 表示层</h4> <p>表示层的作用之一是为 <strong>异种机通信提供一种公共语言，以便能进行互操作</strong>。
这种类型的服务之所以需要，是因为不同的计算机体系结构使用的数据表示法不同。</p> <p>例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来 <strong>实现多种数据格式之间的转换</strong>。</p> <h4 id="_5-3-应用层"><a href="#_5-3-应用层" aria-hidden="true" class="header-anchor">#</a> 5. 3 应用层</h4> <p>是最靠近用户的OSI层。这一层为<strong>用户的应用程序</strong>（例如电子邮件、文件传输和终端仿真）提供网络服务。
应用层包含了我们通常要使用的协议</p> <ul><li><p>HTTP（Hyper Text Transport Protocol）协议：超文本传输协议 ，使用TCP的80端口</p></li> <li><p>FTP（File Transfer Protocol）文件传输协议</p></li> <li><p>SMTP（Simple Mail Transfer Protocol）简单邮件传输协议，TCP的25端口，用户发邮件</p></li> <li><p>POP3（Post Office Protocol Version 3）邮局协议版本3，TCP的110号端口，用于收邮件</p></li> <li><p>DNS（Domain Name System）域名解析协议。使用TCP和UDP的53号端口，作用是把WWW的域名解析成IP地址。</p></li></ul> <h3 id="访问网页发生了什么？"><a href="#访问网页发生了什么？" aria-hidden="true" class="header-anchor">#</a> 访问网页发生了什么？</h3> <p>打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。
这意味着，浏览器要向Google发送一个网页请求的数据包。
网上冲浪开始了。</p> <h4 id="dns协议（把域名变成ip地址）"><a href="#dns协议（把域名变成ip地址）" aria-hidden="true" class="header-anchor">#</a> DNS协议（把域名变成IP地址）</h4> <p>其实访问页面可以有两种方式 IP 和 域名， DNS服务器就可以把域名转换为IP地址。</p> <p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。</p> <p>DNS协议可以帮助我们，将这个网址转换成IP地址。</p> <p>DNS域名解析时用的是UDP协议。</p> <p>已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。
然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p> <h4 id="应用层协议"><a href="#应用层协议" aria-hidden="true" class="header-anchor">#</a> 应用层协议</h4> <p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：
<img src="en-resource://database/1408:1" alt="276d68c65ec9c20ce92a98ee4267036a.png"></p> <p>HTTP部分的内容，类似于下面这样：</p> <div class="language- extra-class"><pre class="language-text"><code>　GET / HTTP/1.1　　
   Host: www.google.com
   Connection: keep-alive
   User-Agent: Mozilla/5.0 (Windows NT 6.1) ......
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
   Accept-Encoding: gzip,deflate,sdch
   Accept-Language: zh-CN,zh;q=0.8
   Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
   Cookie: ... ...
</code></pre></div><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p> <h4 id="tcp协议"><a href="#tcp协议" aria-hidden="true" class="header-anchor">#</a> TCP协议</h4> <p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p> <p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p> <h4 id="ip协议"><a href="#ip协议" aria-hidden="true" class="header-anchor">#</a> IP协议</h4> <p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p> <h4 id="以太网协议"><a href="#以太网协议" aria-hidden="true" class="header-anchor">#</a> 以太网协议</h4> <p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过 <strong>ARP协议</strong> 得到）。</p> <p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。
<img src="en-resource://database/1410:1" alt="d221c428f2a3270263a73b3d641d2079.png"></p> <h4 id="服务器响应"><a href="#服务器响应" aria-hidden="true" class="header-anchor">#</a> 服务器响应</h4> <p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p> <p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的&quot;HTTP请求&quot;，接着做出&quot;HTTP响应&quot;，再用TCP协议发回来。</p> <p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Front/docfront/fenli.html" class="prev">
          记录一下前后端分离的知识
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.d72ea573.js" defer></script><script src="/assets/js/3.d2293747.js" defer></script>
  </body>
</html>
